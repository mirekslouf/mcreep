window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "mcreep", "modulename": "mcreep", "kind": "module", "doc": "<h6 id=\"mcreep-package\">MCREEP package</h6>\n\n<p>Fitting of various pre-defined models to creep data.</p>\n\n<ul>\n<li>The creep data:\n<ul>\n<li>a text file with two columns.</li>\n<li>the 1st column = time, the 2nd column = deformation.</li>\n</ul></li>\n<li>The creep data may come from various experiments:\n<ul>\n<li>tensile creep (standard creep experiment)</li>\n<li>indentation creep with Vickers/Berkovich/spherical tips</li>\n</ul></li>\n<li>The pre-defined models within the pagkage are:\n<ul>\n<li>simple empirical models (Power law, Nutting's law)</li>\n<li>phenomenological models = elasto-visco-plastic models = EVP models</li>\n</ul></li>\n<li>Technical notes:\n<ul>\n<li>tensile creep is usually measured in macroscale</li>\n<li>indentation creep is usually measured in micro/nanoscale</li>\n<li>the models used in this package work for all three scales</li>\n</ul></li>\n</ul>\n\n<p>Typical (simple/minimalistic but complete/working) example is as follows:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (0) Import modules</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">mcreep.const</span><span class=\"o\">,</span> <span class=\"nn\">mcreep.func</span><span class=\"o\">,</span> <span class=\"nn\">mcreep.model</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (1) Define experiment, data and plot parameters</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">EPAR</span> <span class=\"o\">=</span> <span class=\"n\">mcreep</span><span class=\"o\">.</span><span class=\"n\">const</span><span class=\"o\">.</span><span class=\"n\">Experiment</span><span class=\"p\">(</span><span class=\"n\">etype</span><span class=\"o\">=</span><span class=\"s1\">&#39;Vickers&#39;</span><span class=\"p\">,</span> <span class=\"n\">F</span><span class=\"o\">=</span><span class=\"mi\">100</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">DPAR</span> <span class=\"o\">=</span> <span class=\"n\">mcreep</span><span class=\"o\">.</span><span class=\"n\">const</span><span class=\"o\">.</span><span class=\"n\">DataParameters</span><span class=\"p\">(</span><span class=\"n\">deformation_to_um</span><span class=\"o\">=</span><span class=\"mf\">0.001</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">PPAR</span> <span class=\"o\">=</span> <span class=\"n\">mcreep</span><span class=\"o\">.</span><span class=\"n\">const</span><span class=\"o\">.</span><span class=\"n\">PlotParameters</span><span class=\"p\">(</span><span class=\"n\">xlabel</span><span class=\"o\">=</span><span class=\"s1\">&#39;t [s]&#39;</span><span class=\"p\">,</span> <span class=\"n\">ylabel</span><span class=\"o\">=</span><span class=\"s1\">&#39;h [um]&#39;</span><span class=\"p\">)</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (2) Define model (using functions prepared in mcreep.func)</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">MODEL</span> <span class=\"o\">=</span> <span class=\"n\">mcreep</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">Model</span><span class=\"p\">(</span><span class=\"n\">EPAR</span><span class=\"p\">,</span> <span class=\"n\">DPAR</span><span class=\"p\">,</span> <span class=\"n\">PPAR</span><span class=\"p\">,</span>\n<span class=\"gp\">&gt;&gt;&gt; </span>    <span class=\"n\">name</span><span class=\"o\">=</span><span class=\"s1\">&#39;S+D+2KV&#39;</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"o\">=</span><span class=\"n\">mcreep</span><span class=\"o\">.</span><span class=\"n\">func</span><span class=\"o\">.</span><span class=\"n\">evp_s_d_2kv</span><span class=\"p\">,</span> <span class=\"n\">rtimes</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">20</span><span class=\"p\">])</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (3) Run the whole calculation</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">MODEL</span><span class=\"o\">.</span><span class=\"n\">run</span><span class=\"p\">(</span><span class=\"s1\">&#39;pe1.txt&#39;</span><span class=\"p\">,</span> <span class=\"n\">t_start</span><span class=\"o\">=</span><span class=\"mf\">2.2</span><span class=\"p\">,</span> <span class=\"n\">t_hold</span><span class=\"o\">=</span><span class=\"mi\">99</span><span class=\"p\">)</span>\n<span class=\"go\">&gt;&gt;&gt;</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"c1\"># (4) Create report = save and print fitting results</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">MODEL</span><span class=\"o\">.</span><span class=\"n\">final_report</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n"}, {"fullname": "mcreep.const", "modulename": "mcreep.const", "kind": "module", "doc": "<h2 id=\"mcreepconst\">mcreep.const</h2>\n\n<p>Global constants for package mcreep.</p>\n\n<ul>\n<li>Global constants are saved in the form of objects.</li>\n<li>Reason: Object parameters can be [re]defined during initialization.</li>\n</ul>\n"}, {"fullname": "mcreep.const.Experiment", "modulename": "mcreep.const", "qualname": "Experiment", "kind": "class", "doc": "<p>Experiment = object describing the creep experiment.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>etype</strong> (str; which takes one o the following values):\n'Tensile'   = (macroscale) tensile creep experiment.\n'Vickers'   = indentation creep with Vickers tip.\n'Berkovich' = indentation creep with Berkovich tip.\n'Spherical' = indentation creep with spherical tip.</li>\n<li><strong>F</strong> (float; optional, default is None):\nLoading force during indentatin experiments in [mN].\nRelevant (and obligatory) for etype='Vickers/Berkovich/Spherical'.</li>\n<li><strong>R</strong> (float; optional, the default is None):\nRadius of spherical tip in [um].\nRelevant (and obligatory) for etype='Spherical'.</li>\n<li><strong>sigma</strong> (float; optional, default is None):\nStress during tensile experiments in [GPa].\nRelevant (and obligatory) for etype='Tensile'.</li>\n</ul>\n\n<h6 id=\"additional-parameters\">Additional parameters</h6>\n\n<ul>\n<li>m,K = additional constants that are used\nfor correct recalculations of indentation creep data.\nThese parameters are calculated automatically,\nbased on the value of parameter <code>etype</code>.</li>\n<li>const = yet additional constant that is used\nfor correct fitting of EVP models\nto both indentation and tensile creep data with EVP models.\n<ul>\n<li>EVP in general:\n<code>def(t) = const * { A0 + Av*t + Sum[f(Ai,ti)] }</code></li>\n<li>EVP in tensile creep:\n<code>def(t) = epsilon(t)</code> and <code>const = sigma[GPa]</code>     </li>\n<li>EVP in indentation creep:\n<code>def(t) = [h(t)**m]/K</code> and <code>const = F[mN]</code></li>\n<li>Note for indentation creep:\n<ul>\n<li>Mencik_2009: <code>def(t) = h(t)**m</code> and <code>const = F*K</code></li>\n<li>Here (see above): <code>def(t) = [h(t)**m]/K</code> and <code>const = F[mN]</code></li>\n<li>Reason for the difference:\n<ul>\n<li>more consistent treatment of PL x NL x EVP models</li>\n<li>for all models we fit: <code>[h(t)**m]/K</code></li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n\n<h6 id=\"sample-calculation-of-sigma\">Sample calculation of sigma</h6>\n\n<ul>\n<li><code>sigma[GPa] = (load[kg]*SA*g[m/s2]) / (W[mm]*T[mm]/1e6) / 1e9</code></li>\n<li><code>SA</code> = stress amplifier (optional lever amplifying the load)</li>\n<li><code>g</code> = net acceleration = gravity of Earth = 9.81[m/s2]</li>\n<li><code>W,T</code> = width and thickness of testing specimen in [mm]</li>\n<li><code>1e6</code> = recalculate W*T[mm2] -> [m2]</li>\n<li><code>1e9</code> = recalculate final result [Pa] -> [GPa]</li>\n</ul>\n"}, {"fullname": "mcreep.const.Experiment.__init__", "modulename": "mcreep.const", "qualname": "Experiment.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">etype</span>, </span><span class=\"param\"><span class=\"n\">F</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">R</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">sigma</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "mcreep.const.DataParameters", "modulename": "mcreep.const", "qualname": "DataParameters", "kind": "class", "doc": "<p>DataParameters = object defining format of a creep datafile.</p>\n\n<p>Assumptions:</p>\n\n<ul>\n<li>creep datafile is a TXT file containing data in columns;</li>\n<li>one of the columns contains time, some other contains deformation.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>usecols</strong> (list with two integer values; optional, the default is [0,1]):\nThis parameter is passed to numpy.loadtxt.\n<ul>\n<li>The 1st value of the list = column with times.</li>\n<li>The 2nd value of the list = column with deformations.</li>\n</ul></li>\n<li><strong>comments</strong> (string or sequence of strings; optional, the default is '#'):\nThis parameter is passed to numpy.loadtxt.\nThe character(s) indicate comment/ignored lines in input datafile.</li>\n<li><strong>skiprows</strong> (integer; optional, the default is 1):\nThis parameter is passed to numpy.loadtxt.\nThe first {skiprows} lines are skipped.</li>\n<li><strong>time_to_seconds</strong> (float; optional, the default is 1):\nMultiplicative constant, which converts time values to seconds;\nthis conversion is necessary for the following calculations.</li>\n<li><strong>deformation_to_um</strong> (float; optional, the default is 1):\nMultiplicative constant, which converts deformation to micrometers;\nthis conversion is necessary for the following calculations.</li>\n</ul>\n"}, {"fullname": "mcreep.const.DataParameters.__init__", "modulename": "mcreep.const", "qualname": "DataParameters.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">usecols</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">comments</span><span class=\"o\">=</span><span class=\"s1\">&#39;#&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">skiprows</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">time_to_seconds</span><span class=\"o\">=</span><span class=\"mi\">1</span>,</span><span class=\"param\">\t<span class=\"n\">deformation_to_um</span><span class=\"o\">=</span><span class=\"mi\">1</span></span>)</span>"}, {"fullname": "mcreep.const.PlotParameters", "modulename": "mcreep.const", "qualname": "PlotParameters", "kind": "class", "doc": "<p>PlotParameters = object defining local+global parameters for plotting.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>xlabel, ylabel</strong> (str, str):\nLabels for X and Y axis.</li>\n<li><strong>logscale</strong> (bool; optional, the default is False):\nIf logscale==True, both X and Y axes are in logarithmic scale.</li>\n<li><strong>e_to_percent</strong> (bool; optional, the default is True):\nRelevant only to tensile experiments.\nIf true, the values of elongation are multiplied by 100,\ni.e. they are converted from epsilon[] to epsilon[%].</li>\n<li><strong>rcParams</strong> (dict; optional, the default is empty dictionary {}):\nThe dictionary shoud be formatted for mathplotlib.pyplot.rcParams.\nThe argmument is passed to matplotlib.pyplot.\nThe initialization procedure creates some default rcParams.\nThis argument can override this pre-defined parameters,\ni.e. the default is created anyway\nand then (possibly) supplemented by rcParams argument.</li>\n<li><strong>showfigs</strong> (bool; optional, the default is True.):\nIf showfigs==True, the figures are shown + saved in files,\nwhich is default behavior, suitable for running the script in Spyder.\nIf showfigs==False, the figures are just saved in files,\nwhich is an option, suitable for running the script from CLI.</li>\n<li><strong>ax</strong> (matplotlib Axes object, the default is None):\n<ul>\n<li>If ax == None, create and save results as a single plot,\nwhich is a typical usage.</li>\n<li>If ax is defined, create the plot within given ax object,\nwhich can combined with <code>fig,ax = plt.subplots()</code>\nin order to create multile figures.</li>\n</ul></li>\n</ul>\n"}, {"fullname": "mcreep.const.PlotParameters.__init__", "modulename": "mcreep.const", "qualname": "PlotParameters.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">xlabel</span>,</span><span class=\"param\">\t<span class=\"n\">ylabel</span>,</span><span class=\"param\">\t<span class=\"n\">logscale</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">e_to_percent</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">rcParams</span><span class=\"o\">=</span><span class=\"p\">{}</span>,</span><span class=\"param\">\t<span class=\"n\">showfigs</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">ax</span><span class=\"o\">=</span><span class=\"kc\">None</span></span>)</span>"}, {"fullname": "mcreep.const.PlotParameters.set_default_rcParams", "modulename": "mcreep.const", "qualname": "PlotParameters.set_default_rcParams", "kind": "function", "doc": "<p>A class method defining global plot parameters (plt.rcParams).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><p><strong>my_rcParams</strong> (dict):\nThe dictionary re-defines selected plt.rcParams keys.</p>\n\n<p>Example:</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">PlotParameters</span><span class=\"o\">.</span><span class=\"n\">set_default_rcParams</span><span class=\"p\">({</span><span class=\"s1\">&#39;figure.dpi&#39;</span><span class=\"p\">:</span><span class=\"mi\">500</span><span class=\"p\">})</span>\n</code></pre>\n</div></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The function does not return anything,\nBUT it re-defines the global variable rcParams.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>This is a @classmethod (because it is used within the whole class)\nbut it could be a @staticmethod as well (because it does not use\ncls variable in fact).</li>\n<li>The method is employed in two ways:\n<ul>\n<li>Standard usage of MCREEP package: default rcParams are used\n(and possibly modified) in objects of PlotParameters class.</li>\n<li>Special usage of MCREEP (more figures, multiplots): default\nrcParams are used when definining the axes of (multiple) figures.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">cls</span>, </span><span class=\"param\"><span class=\"n\">my_rcParams</span><span class=\"o\">=</span><span class=\"p\">{}</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.fit", "modulename": "mcreep.fit", "kind": "module", "doc": "<h2 id=\"mcreepfit\">mcreep.fit</h2>\n\n<p>Fit various models to creep curves + calculate statistics of fitting.</p>\n"}, {"fullname": "mcreep.fit.fit", "modulename": "mcreep.fit", "qualname": "fit", "kind": "function", "doc": "<p>Fit {MODEL} to {data}.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>MODEL</strong> (mcreep.model.Model object):\nThis object contains all parameters (including fitting function)\nneeded to fit model to data, calculate statistics, and show results.</li>\n<li><strong>data</strong> (2D numpy array):\nNumpy array containing two columns with creep data\n(time and deformation).\nWe note that this procedure is universal and fits data from\nboth indentation and tensile creep experiments\n(see code below and comments inside it).</li>\n<li><strong>t_fstart,t_fend</strong> (float,float):\nThe creep data are fitted to model function in interval\n[t_fstart; t_fend].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>par,cov</strong> (list,list):\nList of regression parameters {par}\nand their covariances {cov}\nfor given fitting function\n(output from function scipy.optimize.curve_fit).</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">MODEL</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">t_fstart</span>, </span><span class=\"param\"><span class=\"n\">t_fend</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.fit.recalculate_deformation", "modulename": "mcreep.fit", "qualname": "recalculate_deformation", "kind": "function", "doc": "<p>Recalculation of deformation\nso that it could be fitted with model function in a correct way.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>EPAR</strong> (Experiment object):\nExperiment object contains information about creep experiment.\nIn this function, we need parameters (EPAR.m,EPAR.K},\nwhich are used for h recalculation.</li>\n<li><strong>Y</strong> (numpy array):\nDeformation data for fitting.\nThis data must be recalculated, as explained below.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Y</strong> (numpy array):\nY-data (= deformation) for fitting.\nThe data are recalculated as necessary.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>Why the recalculation is needed?\n<ul>\n<li>The model function fits different types of deformation,\ndepending on the type of creep experiment.</li>\n<li>Model.EPAR.etype == 'Tensile'\n=&gt; deformation = strain = <code>epsilon(t)</code></li>\n<li>Model.EPAR.etype == 'Vickers' or 'Berkovich' or 'Spherical'\n=&gt; deformation = <code>f[h(t)] = [h(t)**m]/K</code></li>\n<li>The constants <code>m,K</code> are determined automatically within EPAR object\n(where EPAR = mcreep.const.Experiment).</li>\n</ul></li>\n<li>What if we fitted just h(t) for indentatin creep experiments?\n<ul>\n<li>The fitting would work somehow,\nbut the fitting/regression coefficients from idnentation creep\nwould be incompatible with the coefficients from tensile creep.</li>\n<li>Moreover, the fitting coefficients\nfrom different types of indentation experiments\n(for example Vickers vs. spherical) would not be comparable either.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">EPAR</span>, </span><span class=\"param\"><span class=\"n\">Y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.fit.coefficient_of_determination", "modulename": "mcreep.fit", "qualname": "coefficient_of_determination", "kind": "function", "doc": "<p>Calculate R2 = coefficient of determination ~ goodness of fit.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>MODEL</strong> (mcreep.model.Model object):\nThis object contains all properties for calculation.</li>\n<li><strong>par</strong> (list of floats):\nParameters of the fitting function\n(output from mcreep.fit.fit function).</li>\n<li><strong>data</strong> (2D numpy array):\nXY data.\nHere: the creep data used for fitting (X = time, Y = deformation).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>R2</strong> (float):\nThe calculated coefficient of determination.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<ul>\n<li>R2 characterizes how well the data are predicted by fitting function.</li>\n<li>It takes values:\nfrom -oo\n(extremely bad prediction, the mean of the data provides better fit)\nthrough 0\n(poor prediction, the mean of the data provides an equivalent fit)\nto +1\n(perfect prediction).</li>\n<li>More info: <a href=\"https://en.wikipedia.org/wiki/Coefficient_of_determination\">https://en.wikipedia.org/wiki/Coefficient_of_determination</a></li>\n<li>Here, R2 is calculated from the original {data} and {fitting function}.</li>\n<li>The {fitting function} is saved in {MODEL.func}\nand its parameters are supplied in argument {par}.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">MODEL</span>, </span><span class=\"param\"><span class=\"n\">par</span>, </span><span class=\"param\"><span class=\"n\">data</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.func", "modulename": "mcreep.func", "kind": "module", "doc": "<h2 id=\"mcreepfunc\">mcreep.func</h2>\n\n<p>Definition of functions for fitting.</p>\n\n<ul>\n<li>The functions are defined in general form:<code>deformation(t) = f(t)</code></li>\n<li>The package fits the functions to both tensile and indentation creep data.</li>\n</ul>\n\n<p>Pre-defined functions available in current version:</p>\n\n<ul>\n<li>power_law = empirical Power Law model:   <code>deformation(t) = C * t**n</code></li>\n<li>Nutting's law = empirical Nutting's law: <code>deformation(t) = e0 * C * t**n</code></li>\n<li>evp_s_d_1kv = EVP model with Spring + Dashpot + 1 Kelvin/Voight element</li>\n<li>evp_s_d_2kv = EVP model with Spring + Dashpot + 2 Kelvin/Voight elements</li>\n<li>evp_s_d_3kv = EVP model with Spring + Dashpot + 3 Kelvin/Voight elements</li>\n</ul>\n\n<p>The modifications for tensile and indentation creep data:</p>\n\n<ul>\n<li>In both tensile and indentation creep, we have: <code>deformation(t) = f(t)</code>.</li>\n<li>In tensile creep: <code>deformation(t) = strain(t) = epsilon(t)</code>.</li>\n<li>In indentation creep: <code>deformation(t) = [h(t)**m]/K</code>.\n<ul>\n<li>the constants (m,K) are taken from publication {Mencik 2011}</li>\n<li>this ensures the compatibility between tensile and indentation creep</li>\n<li>more details can be found in our own publication {Slouf 2013}</li>\n</ul></li>\n</ul>\n"}, {"fullname": "mcreep.func.power_law", "modulename": "mcreep.func", "qualname": "power_law", "kind": "function", "doc": "<p>Function defining PL model (Power Law model).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\nTime = X-variable for fitting.</li>\n<li><strong>c, n</strong> (float, float):\nParameters of power law model.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Function</strong>: Expression for fitting procedure.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.func.nutting_law", "modulename": "mcreep.func", "qualname": "nutting_law", "kind": "function", "doc": "<p>Function defining NL model (Nutting's law/model).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\nTime = X-variable for fitting.</li>\n<li><strong>e0, c, n</strong> (float, float, float):\nParameters of Nutting's model.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Function</strong>: Expression for fitting procedure.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">e0</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.func.evp_s_d_1kv", "modulename": "mcreep.func", "qualname": "evp_s_d_1kv", "kind": "function", "doc": "<p>Function defining EVP model with elements [S + D + 1*KV].</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\nTime = X-variable for fitting.</li>\n<li><strong>const</strong> (float):\nMultiplicative constant for EVP models.\n<ul>\n<li>Tensile experiments: const = applied stress = sigma[GPa]\n<ul>\n<li><code>sigma</code> = constant, calculated+saved in mcreep.const.Experiment</li>\n</ul></li>\n<li>Indentation experiments: const = <code>F*K</code>\n<ul>\n<li><code>F[mN]</code> = loading force</li>\n<li><code>K</code> = constant, calculated+saved in mcreep.const.Experiment</li>\n</ul></li>\n</ul></li>\n<li><strong>B0</strong> (float):\nParameter corresponding to S-element of EVP model.</li>\n<li><strong>Cv</strong> (float):\nParameter corresponding to D-element of EVP model.</li>\n<li><strong>D1</strong> (float):\nParameter of KV-element of EVP model ~ compliance.</li>\n<li><strong>tau1</strong> (float):\nParameter of KV-element of EVP model = retardation time.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Function</strong>: Expression for fitting procedure.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">const</span>, </span><span class=\"param\"><span class=\"n\">B0</span>, </span><span class=\"param\"><span class=\"n\">Cv</span>, </span><span class=\"param\"><span class=\"n\">D1</span>, </span><span class=\"param\"><span class=\"n\">tau1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.func.evp_s_d_2kv", "modulename": "mcreep.func", "qualname": "evp_s_d_2kv", "kind": "function", "doc": "<p>Function defining EVP model with elements [S + D + 2*KV].</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\nTime = X-variable for fitting.</li>\n<li><strong>const</strong> (float):\nMultiplicative constant for EVP models.\n<ul>\n<li>Tensile experiments: const = applied stress = sigma[GPa]\n<ul>\n<li><code>sigma</code> = constant, calculated+saved in mcreep.const.Experiment</li>\n</ul></li>\n<li>Indentation experiments: const = <code>F*K</code>\n<ul>\n<li><code>F[mN]</code> = loading force</li>\n<li><code>K</code> = constant, calculated+saved in mcreep.const.Experiment</li>\n</ul></li>\n</ul></li>\n<li><strong>B0</strong> (float):\nParameter corresponding to S-element of EVP model.</li>\n<li><strong>Cv</strong> (float):\nParameter corresponding to D-element of EVP model.</li>\n<li><strong>D1, D2</strong> (float, float):\nParameters of KV-elements of EVP model ~ compliance.</li>\n<li><strong>tau1, tau2</strong> (float, float):\nParameters of KV-elements of EVP model = retardation times.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Function</strong>: Expression for fitting procedure.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">const</span>, </span><span class=\"param\"><span class=\"n\">B0</span>, </span><span class=\"param\"><span class=\"n\">Cv</span>, </span><span class=\"param\"><span class=\"n\">D1</span>, </span><span class=\"param\"><span class=\"n\">D2</span>, </span><span class=\"param\"><span class=\"n\">tau1</span>, </span><span class=\"param\"><span class=\"n\">tau2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.func.evp_s_d_3kv", "modulename": "mcreep.func", "qualname": "evp_s_d_3kv", "kind": "function", "doc": "<p>Function defining EVP model with elements [S + D + 3*KV].</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>t</strong> (float):\nTime = X-variable for fitting.</li>\n<li><strong>const</strong> (float):\nMultiplicative constant for EVP models.\n<ul>\n<li>Tensile experiments: const = applied stress = sigma[GPa]\n<ul>\n<li><code>sigma</code> = constant, calculated+saved in mcreep.const.Experiment</li>\n</ul></li>\n<li>Indentation experiments: const = <code>F*K</code>\n<ul>\n<li><code>F[mN]</code> = loading force</li>\n<li><code>K</code> = constant, calculated+saved in mcreep.const.Experiment</li>\n</ul></li>\n</ul></li>\n<li><strong>B0</strong> (float):\nParameter corresponding to S-element of EVP model.</li>\n<li><strong>Cv</strong> (float):\nParameter corresponding to D-element of EVP model.</li>\n<li><strong>D1, D2, D3</strong> (float, float, float):\nParameters of KV-elements of EVP model ~ compliance.</li>\n<li><strong>tau1, tau2, tau3</strong> (float, float, float):\nParameters of KV-elements of EVP model = retardation times.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Function</strong>: Expression for fitting procedure.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">t</span>, </span><span class=\"param\"><span class=\"n\">const</span>, </span><span class=\"param\"><span class=\"n\">B0</span>, </span><span class=\"param\"><span class=\"n\">Cv</span>, </span><span class=\"param\"><span class=\"n\">D1</span>, </span><span class=\"param\"><span class=\"n\">D2</span>, </span><span class=\"param\"><span class=\"n\">D3</span>, </span><span class=\"param\"><span class=\"n\">tau1</span>, </span><span class=\"param\"><span class=\"n\">tau2</span>, </span><span class=\"param\"><span class=\"n\">tau3</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.io", "modulename": "mcreep.io", "kind": "module", "doc": "<h2 id=\"mcreepio\">mcreep.io</h2>\n\n<p>Input/output functions for package mcreep.</p>\n"}, {"fullname": "mcreep.io.read_datafile", "modulename": "mcreep.io", "qualname": "read_datafile", "kind": "function", "doc": "<p>Read datafile containing creep data.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>MODEL</strong> (MODEL object):\nThe object keeps experiment parameters in MODEL.EPAR property.\nWe use the object to convert time and deformation to correct units.</li>\n<li><strong>datafile</strong> (string or pathlib object):\nName of datafile = a text file containing\nat least two columns (time,deformation);\nsee section {Expected format of the datafile}\nbelow for more information.</li>\n<li><strong>t_start</strong> (float):\nStart of step II = holding step = period at which F = Fmax.</li>\n<li><strong>t_end</strong> (float):\nEnd of step II = holding step = period at which F = Fmax.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>2D numpy array.</strong></li>\n</ul>\n\n<h6 id=\"expected-format-of-the-datafile\">Expected format of the datafile</h6>\n\n<ul>\n<li>Two colums (time,deformation) separated by whitespace.\n<ul>\n<li>1st column = t[s] = time in seconds</li>\n<li>2nd column = deformation[um] = deformation in micrometers\n<ul>\n<li>in tensile experiments: deformation = strain</li>\n<li>in indentation experiments: deforamtion = penetration depth</li>\n</ul></li>\n</ul></li>\n<li>The datafile is read by means of numpy.loadtxt function\nand some parameters can be adjusted by means of MODEL argument\n(which contains DataParameters object describing the input data):\n<ul>\n<li>see source code of this function</li>\n<li>and mcreep.const.DataParameters object</li>\n<li>for example, it is possible to specify column numbers\nif the datafile contains more columns than required</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">MODEL</span>, </span><span class=\"param\"><span class=\"n\">datafile</span>, </span><span class=\"param\"><span class=\"n\">t_start</span>, </span><span class=\"param\"><span class=\"n\">t_hold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.io.print_fitting_result", "modulename": "mcreep.io", "qualname": "print_fitting_result", "kind": "function", "doc": "<p>Print ONE result of fitting\n(i.e. print fitting results for one/currently processed datafile).</p>\n\n<p>We note that the complete results of fitting (for all datafiles)\nare kept in mcreep.model.Model object and usually reported/printed\ntogether at the very end of the whole processing.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>MODEL</strong> (mcreep.model.Model object):\nThis object contains all properties needed to print the result.</li>\n<li><strong>datafile</strong> (str):\nName of the datafile;\nin this procedure, it is just printed to stdout\nin order to denote the source of the fitting results.</li>\n<li><strong>par</strong> (list of floats):\nList of optimized parameters of given fitting function;\noutput from the procedure mcreep.fit.fit.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output are results printed on stdout.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">MODEL</span>, </span><span class=\"param\"><span class=\"n\">datafile</span>, </span><span class=\"param\"><span class=\"n\">par</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.io.plot_fitting_result", "modulename": "mcreep.io", "qualname": "plot_fitting_result", "kind": "function", "doc": "<p>Plot the result of fitting (single plot OR axes defined within MODEL).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>MODEL</strong> (mcreep.model.Model object):\nThis object contains all properties needed to print the result.</li>\n<li><strong>datafile</strong> (str or path-like object):\nName of the datafile containing input data.\n<ul>\n<li>Important: We use this argument just for creating\nthe name of the output graph =&gt; {datafile}.png.</li>\n<li>If MODEL.PPAR.ax == None: the output goes to single PNG file,\nwhose name is created as <code>datafile.PNG</code>.</li>\n<li>If MODEL.PPAR.ax != None: the output goes to pre-prepared axes\nobject, and datafile parameter is ignored.</li>\n</ul></li>\n<li><strong>data</strong> (2D numpy array):\nCreep data read from the currently processed datafile.\nIt is expectted</li>\n<li><strong>par</strong> (list of floats):\nList of optimized parameters of given fitting function;\noutput from the procedure mcreep.fit.fit.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is either single plot OR axes in a multiplot.\n<ul>\n<li>If MODEL.PPAR.ax == None:\na single output graph is shown (option) + saved (always).\nThe name of the output graph is {datafile}.png.</li>\n<li>If MODEL.PPAR.ax == axes_object\na graphs is created within the pre-defined axes_object.\nThis can be employed in creating user-defined multiplots.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">MODEL</span>, </span><span class=\"param\"><span class=\"n\">datafile</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">par</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.io.recalculate_fitted_data", "modulename": "mcreep.io", "qualname": "recalculate_fitted_data", "kind": "function", "doc": "<p>Recalculation of the fitted/calculated data before plotting.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>EPAR</strong> (Experiment object):\nObject with experimental parameters.\nIn this function, we need (EPAR.m,EPAR.K) for Y-data recalculation.</li>\n<li><p><strong>Y_orig</strong> (1D numpy array.):\nOriginal Y-data, to which f(t) was fitted.\nThe data have to be recalculated, because...</p>\n\n<ul>\n<li>The models could be fitted to tensile or indentation creep data.\n<ul>\n<li>Tensile creep data were not modified: deformation(t) = epsilon(t)</li>\n<li>Indentation creep data were modified: deformation(t) = (h**m)/K)</li>\n</ul></li>\n<li>The modification is necessary in order to achieve\ncompatibility between tensile and indentation creep results.\n<ul>\n<li>More precisely, indentation creep data are recalculated\nso that the results\nfrom (specific) fitting of models to indentation creep data\nare compatible with the results\nfrom (standard) fitting of models to tensile creep data.</li>\n</ul></li>\n<li>For INDENTATION CREEP, the modification means that...\n<ul>\n<li>Model was not fitted to [h(t)] but to [h(t)<strong>m]/K</li>\n<li>Fitted data calculated from model are [h(t)</strong>m]/K</li>\n<li>These data have to be calculated to [h(t)] before plotting:\n<ul>\n<li><code>Y_orig = [h(t)**m]/K</code></li>\n<li><code>h(t) = (Y_orig * K) ** (1/m)</code></li>\n</ul></li>\n</ul></li>\n</ul></li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Y_recalc</strong> (1D numpy array):\nRecalculated Y-data for plotting.\nThe recalculated data are:\n    * epsilon(t) for tensile creep\n    * h(t) for indentation creep</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">EPAR</span>, </span><span class=\"param\"><span class=\"n\">Y_orig</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model", "modulename": "mcreep.model", "kind": "module", "doc": "<h2 id=\"mcreepmodel\">mcreep.model</h2>\n\n<p>Definition of Model for fitting the creep data + functions to run it.</p>\n\n<p>The module defines Model class, whose object/instance contains:</p>\n\n<ul>\n<li>Properties for fitting model to data:\n<ol>\n<li>property func: definition of fitting function</li>\n<li>property table_of_results: for saving the results of fitting</li>\n<li>and a few other properties, which can modify the fitting prodedure.</li>\n</ol></li>\n<li>Functions/methods for fitting model to data - the most important are:\n<ol>\n<li>Model.run, which runs the whole calculation</li>\n<li>Model.describe, which briefly describes the model (for outputs, reports)</li>\n<li>Model.final_report, which creates final reports from ALL fitting results</li>\n</ol></li>\n<li>Three objects describing the input/output data:\n<ol>\n<li>mcreep.const.Experiment = description of experiment</li>\n<li>mcreep.const.DataParameters = description of input data</li>\n<li>mcreep.const.PlotParameters = description of the output plot</li>\n</ol></li>\n</ul>\n"}, {"fullname": "mcreep.model.Model", "modulename": "mcreep.model", "qualname": "Model", "kind": "class", "doc": "<p>Model for fitting creep data, containing namely:</p>\n\n<ul>\n<li>fitting function (a function selected from mcreep.func)</li>\n<li>methods to run the fitting (employing also mcreep.io, mcreep.fit)</li>\n<li>table/dataframe with results of fitting; updated during calculations</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>EPAR</strong> (mcreep.const.Experiment object):\nDescription of experimental parameters (such as experiment type...).</li>\n<li><strong>DPAR</strong> (mcreep.const.DataParameters object):\nDescription of data (such as which columns to read, rows to skip...)</li>\n<li><strong>PPAR</strong> (mcreep.const.PlotParameters object):\nDefinition of plot parameters (xlabel, ylabel, global properties...).</li>\n<li><strong>name</strong> (str):\nName of the fitting function in human-readable form.</li>\n<li><strong>func</strong> (function object):\nOne of the fitting functions defined in module mcreep.func,\nsuch as <code>mcreep.func.power_law</code>, <code>mcreep.func.evp_s_d_1kv</code>, ...</li>\n<li><strong>rtimes</strong> (list of floats; optional, default is None):\nList of retardation times.\nIf defined, the retardation times of EVP fitting functions\nare fixed at given values.</li>\n<li><strong>iguess</strong> (list of floats; default is None):\nInitial guess = list of starting values for fitting.\nThe number of values must correspond to variables in given model.\nIf defined, iguess parameter is passed to scipy.optimize.curve_fit</li>\n<li><strong>output_dir</strong> (str or path-like object; optional, default is '.'):\nDirectory for output files.\nIf not given, we use current directory,\ni.e. the directory of the script that runs the program.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Model object</strong> ():\n<ul>\n<li>The Model.__init__ function\nreturns the object with all properties and methods</li>\n<li>The Model.run function\nfits the selected model function to experimental creep data\nand saves the results to Model.table_of_results property.</li>\n</ul></li>\n</ul>\n\n<h6 id=\"additional-parameters\">Additional parameters</h6>\n\n<ul>\n<li>table_of_results : pandas.DataFrame\n<ul>\n<li>Table of fitting results, which contains\ndatafile name + values of fitted variables.</li>\n</ul></li>\n<li>table_of_results_evp : pandas.DataFrame\n<ul>\n<li>Table of recalculated fitting results for EVP models, containing:\n<ul>\n<li>final compliances: <code>C0,Cv,C1,C2...</code></li>\n<li>final retardation times: <code>tau1,tau2...</code></li>\n</ul></li>\n<li>These values can be used to predict E(t):\n<ul>\n<li><code>E(t) = f(C0,Cv,C1...,tau1...)</code></li>\n</ul></li>\n</ul></li>\n</ul>\n"}, {"fullname": "mcreep.model.Model.__init__", "modulename": "mcreep.model", "qualname": "Model.__init__", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">EPAR</span>,</span><span class=\"param\">\t<span class=\"n\">DPAR</span>,</span><span class=\"param\">\t<span class=\"n\">PPAR</span>,</span><span class=\"param\">\t<span class=\"n\">name</span>,</span><span class=\"param\">\t<span class=\"n\">func</span>,</span><span class=\"param\">\t<span class=\"n\">rtimes</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">iguess</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">output_dir</span><span class=\"o\">=</span><span class=\"s1\">&#39;.&#39;</span></span>)</span>"}, {"fullname": "mcreep.model.Model.describe", "modulename": "mcreep.model", "qualname": "Model.describe", "kind": "function", "doc": "<p>Print brief description of the fitting model and its outputs.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>fh</strong> (filehandle; optional, default is sys.stdout):\nBy default, the model description is printed on stdout.\nIf {fh} is given, the output is redirected to {fh} filehandle.\nReason: the description can be printed both to stdout\nand to text file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: The output is the text printed to stdout or text file.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fh</span><span class=\"o\">=&lt;</span><span class=\"n\">_io</span><span class=\"o\">.</span><span class=\"n\">StringIO</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.run", "modulename": "mcreep.model", "qualname": "Model.run", "kind": "function", "doc": "<p>Run the model = fit model functin to experimental data.</p>\n\n<ul>\n<li>This includes reading data + fitting + plotting + saving results.</li>\n<li>The method employs other functions defined mcreep.io + mcreep.fit.</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>datafile</strong> (str or path-like object):\nFull name of the datafile containing creep data.</li>\n<li><strong>t_start</strong> (float):\nThe creep data are read for the interval\n[t_start; t_start+t_hold];\nt_start is the initial time for the data reading.\n    For indentation experiments, t_start ~ when Fmax is reached.\n    For tensile experiments, t_start ~ the first detected time.\n    Alternatively, t_start can be a bit higher\n    in order to avoid initial period.</li>\n<li><strong>t_hold</strong> (float):\nThe creep data are read for the interval\n[t_start; t_start+t_hold];\nt_hold is used to calculate the final time for the data reading.\n    For both indentation and tensile experiments,\n    it is the time for which the Fmax is held.\n    It is reasonable to insert a slightly lower time\n    (to be safe + to consider possible increase in t_start).</li>\n<li><strong>t_fstart</strong> (float; optional):\nThe model function is fitted to creep data in the interval\n[t_fstart; t_fend].\nIf t_fstart is not given, it is set equal to t_start;\ni.e. the function is fitted to all data that were read.</li>\n<li><strong>t_fend</strong> (float; optional):\nThe model function is fitted to creep data in the interval\n[t_fstart; t_fend].\nIf t_fstart is not given, it is set equal to (t_start + t_hold);\ni.e. the function is fitted to all data that were read.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><p><strong>None</strong>: Nevertheless, this is the key method of {Model} object which...</p>\n\n<ul>\n<li>reads creep data</li>\n<li>fits model function to creep data</li>\n<li>saves results to self.table_of_results\nand self.table_of_results_evp</li>\n<li>Note: the printing and saving data to file\nis performed after running the model (self.run)\nby means of another method (self.final_report).</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">datafile</span>, </span><span class=\"param\"><span class=\"n\">t_start</span>, </span><span class=\"param\"><span class=\"n\">t_hold</span>, </span><span class=\"param\"><span class=\"n\">t_fstart</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">t_fend</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.read_datafile", "modulename": "mcreep.model", "qualname": "Model.read_datafile", "kind": "function", "doc": "<p>Read datafile with creep data\n(just a wrapper for function mcreep.io.read_datafile).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">datafile</span>, </span><span class=\"param\"><span class=\"n\">t_start</span>, </span><span class=\"param\"><span class=\"n\">t_hold</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.fit_function_to_data", "modulename": "mcreep.model", "qualname": "Model.fit_function_to_data", "kind": "function", "doc": "<p>Fit model function to creep data\n(just a wrapper for function mcreep.fit.fit).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">t_fstart</span>, </span><span class=\"param\"><span class=\"n\">t_fend</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.print_fitting_result", "modulename": "mcreep.model", "qualname": "Model.print_fitting_result", "kind": "function", "doc": "<p>Print the results of creep data fitting with given model.\n(just a wrapper for function mcreep.io.print_fitting_result).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">datafile</span>, </span><span class=\"param\"><span class=\"n\">par</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.plot_fitting_result", "modulename": "mcreep.model", "qualname": "Model.plot_fitting_result", "kind": "function", "doc": "<p>Save the results of creep data fitting with given model.\n(just a wrapper for function mcreep.io.plot_fitting_result).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">datafile</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">par</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.calculate_statistics", "modulename": "mcreep.model", "qualname": "Model.calculate_statistics", "kind": "function", "doc": "<p>Calculate statistics for model function fitted to creep data.\nIt calls mcreep.fit.coefficient_of_determination twice:</p>\n\n<ul>\n<li>once for all data (= data in interval [t_start, t_start+t_hold])</li>\n<li>once for fitted data (= data in interval [t_fstart, t_fend])</li>\n</ul>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>par</strong> (list of floats):\nResult of fitting procedure;\nusually the result of procedure mcreep.fit.fit.</li>\n<li><strong>data</strong> (2D-numpy array):\nCrep data read from input datafile;\nusually the result of procedure mcreep.io.read_datafile.</li>\n<li><strong>t_fstart, t_fend</strong> (float, float):\nTimes determining the fitting interval = [t_fstart; t_fend].</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>R2fit, R2all</strong> (float, float):\nCoefficients of determination for data in fitting interval\n[t_fstart, t_fend] and for the whole dataset in interval\n[t_start, t_start+t_hold].</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">par</span>, </span><span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">t_fstart</span>, </span><span class=\"param\"><span class=\"n\">t_fend</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.save_fitting_result", "modulename": "mcreep.model", "qualname": "Model.save_fitting_result", "kind": "function", "doc": "<p>Save the results of fitting to Model object.\nThe fitting results are saved in two object properties:</p>\n\n<ul>\n<li>self.table_of_results = the results of fitting</li>\n<li>self.table_of_results_evp = recalculated results for EVP models</li>\n</ul>\n\n<p>The saved results in Model object can be printed and saved using\nanother property mcreep.model.Model.final_report.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>datafile</strong> (str):\nDatafile containing creep data.\nIn this function it is used just for output;\nthe (shortened) datafile name denotes the processed dataset.</li>\n<li><strong>par</strong> (list of floats):\nResult of fitting procedure;\nusually the result of procedure mcreep.fit.fit.</li>\n<li><strong>R2fit, R2all</strong> (float, float):\nCoefficients of determination for fitting interval and all data;\noutput of the function mcreep.model.Model.calculate_statistics.</li>\n<li><strong>t_start</strong> (float):\nStarting time of fitting.\nIn this procedure it is used for calculation of\nRCF = Ramp Correction Factors of EVP models\n(see the notes inside the code).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: * Formally it returns self, but this is not necessary.\n<ul>\n<li>The result are fitting results saved in self = in Model object.</li>\n</ul></li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">datafile</span>, </span><span class=\"param\"><span class=\"n\">par</span>, </span><span class=\"param\"><span class=\"n\">R2fit</span>, </span><span class=\"param\"><span class=\"n\">R2all</span>, </span><span class=\"param\"><span class=\"n\">t_start</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.final_report", "modulename": "mcreep.model", "qualname": "Model.final_report", "kind": "function", "doc": "<p>Print and save final report = summarize the results of fitting.\nThe report is calls the following methods\nof Model object:</p>\n\n<ul>\n<li>Model.describe = basic text description of the model.</li>\n<li>Model.print_table_of_results = print results of fitting.</li>\n<li>Model.print_table_of_results_evp = print addidional results\nof fitting for EVP models.</li>\n</ul>\n\n<p>The results are both printed and saved in the text file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>output_file</strong> (str, optional):\nName of the output text file, into which the results are saved.\nIf the parameter is given</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>None</strong>: Output is the printed report\nand saved file with the results of fitting.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">output_file</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.print_table_of_results", "modulename": "mcreep.model", "qualname": "Model.print_table_of_results", "kind": "function", "doc": "<p>Print table of results as text\n(this is done by a small trick employing pandas.DataFrame).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.print_table_of_results_evp", "modulename": "mcreep.model", "qualname": "Model.print_table_of_results_evp", "kind": "function", "doc": "<p>Print table of additional result of EVP models as text\n(this is done by a small trick employing pandas.DataFrame).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.save_table_of_results", "modulename": "mcreep.model", "qualname": "Model.save_table_of_results", "kind": "function", "doc": "<p>Save table of results as text\n(this is done by a small trick employing pandas.DataFrame).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fh</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "mcreep.model.Model.save_table_of_results_evp", "modulename": "mcreep.model", "qualname": "Model.save_table_of_results_evp", "kind": "function", "doc": "<p>Save table of additional results of EVP models as text\n(this is done by a small trick employing pandas.DataFrame).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">fh</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();